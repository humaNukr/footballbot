from aiogram import Router, F, types
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from pyexpat.errors import messages

from app.db.database import Database
from app.keyboards.inline import faq_main_menu
from app.db.models import add_user, save_feedback

from app.keyboards.inline import back_to_menu
from app.keyboards.reply import start_keyboard

from app.keyboards.reply import get_main_panel
from app.services.notify import push_feedback_update
from app.states.register import FeedbackStates, GameStates

router = Router()


@router.message(CommandStart())
async def cmd_start(message: Message):
    await message.answer(
        "–ü—Ä–∏–≤—ñ—Ç! –ü—ñ–¥—Ç–≤–µ—Ä–¥—ñ—Ç—å, —â–æ –≤–∏ –ø–æ–≥–æ–¥–∂—É—î—Ç–µ—Å—è –∑ –ø–æ–ª—ñ—Ç–∏–∫–æ—é –∫–æ–Ω—Ñ—ñ–¥–µ–Ω—Ü—ñ–π–Ω–æ—Å—Ç—ñ ‚öΩ",
        reply_markup=start_keyboard
    )


@router.message(F.text == "üöÄ –ü–æ–≥–æ–¥–∂—É—é—Å—è")
async def process_start_button(message: Message, is_registered: bool, is_admin: bool):
    await message.answer(
        "–í–∏–±–µ—Ä—ñ—Ç—å –æ–¥–Ω—É –∑ –æ–ø—Ü—ñ–π:",
        reply_markup=get_main_panel(is_registered, is_admin)
    )


# FAQ LOGIC
@router.message(F.text == "‚ùì FAQ")
async def show_faq_menu(message: Message):
    await message.answer(
        "–¶–µ —Ä–æ–∑–¥—ñ–ª–∏ –Ω–∞–π—á–∞—Å—Ç—ñ—à–∏—Ö –ø–∏—Ç–∞–Ω—å ‚ùó")

    keyboard = faq_main_menu()

    await message.answer("‚ùì <b>–í–∏–±–µ—Ä–∏ —Ä–æ–∑–¥—ñ–ª:</b>", reply_markup=keyboard)


# –í—ñ–¥–ø–æ–≤—ñ–¥—ñ –Ω–∞ callback-–∏
@router.callback_query(F.data == "faq_about")
async def faq_about(callback: CallbackQuery):
    await callback.message.edit_text(
        "ü§ñ <b>–î–ª—è —á–æ–≥–æ —Ü–µ–π –±–æ—Ç?</b>\n\n"
        "–©–æ–± –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ—Ä–≥–∞–Ω—ñ–∑–æ–≤—É–≤–∞—Ç–∏ —Ñ—É—Ç–±–æ–ª—å–Ω—ñ –º–∞—Ç—á—ñ. "
        "–ë–æ—Ç —Ä–æ–∑—Å–∏–ª–∞—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, –æ—Ç—Ä–∏–º—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ —ñ —Ä–∞—Ö—É—î –∫—ñ–ª—å–∫—ñ—Å—Ç—å —É—á–∞—Å–Ω–∏–∫—ñ–≤.",
        reply_markup=back_to_menu()
    )
    await callback.answer()


@router.callback_query(F.data == "faq_matches")
async def faq_matches(callback: CallbackQuery):
    await callback.message.edit_text(
        "üìÖ <b>–ö–æ–ª–∏ –±—É–¥–µ –Ω–∞—Å—Ç—É–ø–Ω–∞ –≥—Ä–∞?</b>\n\n"
        "–ê–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä —Å–∞–º –≤–∏—Ä—ñ—à—É—î —ñ –∑–∞–ø—É—Å–∫–∞—î —Ä–æ–∑—Å–∏–ª–∫—É. –í–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —ñ –∑–º–æ–∂–µ—Ç–µ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ —É—á–∞—Å—Ç—å.",
        reply_markup=back_to_menu()
    )
    await callback.answer()


@router.callback_query(F.data == "faq_admin")
async def faq_admin(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text(
        "üõ†Ô∏è <b>–•–æ—á–µ—Ç–µ —â–æ—Å—å –∑–∞–ø—Ä–æ–ø–æ–Ω—É–≤–∞—Ç–∏ –∞–±–æ –ø–æ–≤—ñ–¥–æ–º–∏—Ç–∏ –ø—Ä–æ –±–∞–≥</b>\n\n"
        "–ù–∞–ø–∏—à–∏ —Å–≤–æ—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑–Ω–∏–∑—É",
        reply_markup=back_to_menu()
    )
    await state.set_state(FeedbackStates.waiting_for_text)
    await callback.answer()


@router.callback_query(F.data == "faq_back")
async def faq_back(callback: CallbackQuery):
    keyboard = faq_main_menu()
    await callback.message.edit_text("‚ùì <b>–í–∏–±–µ—Ä–∏ —Ä–æ–∑–¥—ñ–ª:</b>", reply_markup=keyboard)
    await callback.answer()


# ADMIN LOGIC
@router.message(F.text == "üîê –ê–¥–º—ñ–Ω-–ø–∞–Ω–µ–ª—å")
async def admin_panel_button(message: Message, is_admin: bool):
    from app.keyboards.inline import admin_main_menu
    await message.answer(
        "üîê <b>–ê–¥–º—ñ–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n"
        "–í–∏–±–µ—Ä—ñ—Ç—å –¥—ñ—é:",
        reply_markup=admin_main_menu()
    )


@router.message(F.text == "üí¨ –ó–∞–ª–∏—à–∏—Ç–∏ –≤—ñ–¥–≥—É–∫")
async def start_feedback(message: Message, state: FSMContext):
    await message.answer("üìù –ù–∞–ø–∏—à—ñ—Ç—å —Å–≤—ñ–π –≤—ñ–¥–≥—É–∫ —É –Ω–∞—Å—Ç—É–ø–Ω–æ–º—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—ñ:")
    await state.set_state(FeedbackStates.waiting_for_text)


@router.message(FeedbackStates.waiting_for_text)
async def process_feedback_text(message: Message, state: FSMContext, db: Database):
    feedback_text = message.text.strip()

    if not feedback_text:
        await message.answer("‚ùóÔ∏è –í—ñ–¥–≥—É–∫ –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –ø–æ—Ä–æ–∂–Ω—ñ–º. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")
        return

    user_id = message.from_user.id

    try:
        await save_feedback(db, user_id, feedback_text)
        await push_feedback_update(message, state, db)
        await message.answer("‚úÖ –î—è–∫—É—î–º–æ –∑–∞ –≤–∞—à–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è. –ê–¥–º—ñ–Ω –ø—Ä–æ—á–∏—Ç–∞—î —Ü–µ –Ω–µ–∑–∞–±–∞—Ä–æ–º!")
    except Exception as e:
        await message.answer("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤—ñ–¥–≥—É–∫—É.")
        print(f"[FEEDBACK ERROR] {e}")

    await state.clear()


@router.message(F.text == "üìÖ –†–æ–∑–∫–ª–∞–¥")
async def show_schedule(message: Message, db: Database):
    query = """
            SELECT s.id, s.first_name, s.date, s.time, s.message
            FROM schedule s
            ORDER BY s.date, s.time \
            """
    result = await db.fetchall(query)

    if not result:
        await message.answer(
            "üì≠ <b>–†–æ–∑–∫–ª–∞–¥ –ø–æ–∫–∏ —â–æ –ø–æ—Ä–æ–∂–Ω—ñ–π</b>\n\n"
            "üîî –í–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, –∫–æ–ª–∏ –∞–¥–º—ñ–Ω –¥–æ–¥–∞—Å—Ç—å –Ω–æ–≤–∏–π –º–∞—Ç—á!\n\n"
            "‚öΩ –ì–æ—Ç—É–π—Ç–µ—Å—è –¥–æ –≥—Ä–∏!"
        )
        return

    from datetime import datetime
    matches_by_date = {}
    for row in result:
        match_id, first_name, date, time_, msg = row
        date_key = str(date)
        if date_key not in matches_by_date:
            matches_by_date[date_key] = []
        matches_by_date[date_key].append((match_id, first_name, date, time_, msg))

    match_count = 0
    for date_key, matches in matches_by_date.items():
        try:
            date_obj = datetime.strptime(date_key, "%Y-%m-%d")
            formatted_date = date_obj.strftime("%d.%m.%Y")
            day_name = ["–ü–æ–Ω–µ–¥—ñ–ª–æ–∫", "–í—ñ–≤—Ç–æ—Ä–æ–∫", "–°–µ—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä", "–ü'—è—Ç–Ω–∏—Ü—è", "–°—É–±–æ—Ç–∞", "–ù–µ–¥—ñ–ª—è"][date_obj.weekday()]
        except:
            formatted_date = date_key
            day_name = ""

        for match_id, first_name, date, time_, msg in matches:
            match_count += 1
            text = (
                f"üéØ <b>–ú–∞—Ç—á #{match_count}</b>\n"
                f"üìÖ <b>–î–∞—Ç–∞:</b> {formatted_date} ({day_name})\n"
                f"üïê <b>–ß–∞—Å:</b> {time_}\n"
                f"üë®‚Äçüíº <b>–û—Ä–≥–∞–Ω—ñ–∑–∞—Ç–æ—Ä:</b> {first_name}\n"
                f"üìã <b>–î–µ—Ç–∞–ª—ñ:</b> {msg}\n"
                f"‚ö°  <i>–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å, —â–æ–± –∑–∞–ø–∏—Å–∞—Ç–∏—Å—è üëá</i>\n"
                f"üî• <i>–§—É—Ç–±–æ–ª - —Ü–µ –∂–∏—Ç—Ç—è!</i> üî•"
            )

            keyboard = InlineKeyboardMarkup(
                inline_keyboard=[
                    [
                        InlineKeyboardButton(text="‚úÖ –ü—Ä–∏–π–¥—É", callback_data=f"register_match:{match_id}"),
                        InlineKeyboardButton(text="‚ùå –ù–µ –ø—Ä–∏–π–¥—É", callback_data=f"unregister_match:{match_id}"),
                    ],
                    [
                        InlineKeyboardButton(text="üë• –£—á–∞—Å–Ω–∏–∫–∏", callback_data=f"match_participants:{match_id}")
                    ]
                ]
            )

            await message.answer(text, reply_markup=keyboard, parse_mode="HTML")


@router.callback_query(F.data.startswith("register_match:"))
async def register_to_match(callback: CallbackQuery, db: Database):
    match_id = int(callback.data.split(":")[1])
    telegram_id = callback.from_user.id
    username = callback.from_user.username

    try:
        query_user = "SELECT first_name FROM users WHERE telegram_id = %s"
        result = await db.fetchone(query_user, (telegram_id,))

        if not result:
            await callback.answer("‚ùå –í–∏ –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω—ñ –≤ —Å–∏—Å—Ç–µ–º—ñ.", )
            return

        first_name = result[0]

        insert_query = """
                       INSERT INTO registrations (match_id, telegram_id, first_name, username)
                       VALUES (%s, %s, %s, %s) \
                       """
        await db.execute(insert_query, (match_id, telegram_id, first_name, username))

        await callback.answer("‚úÖ –í–∏ —É—Å–ø—ñ—à–Ω–æ –∑–∞–ø–∏—Å–∞–ª–∏—Å—è –Ω–∞ –º–∞—Ç—á!")

    except Exception as e:
        if "Duplicate entry" in str(e):
            await callback.answer("‚ö†Ô∏è –í–∏ –≤–∂–µ –∑–∞–ø–∏—Å–∞–Ω—ñ –Ω–∞ —Ü–µ–π –º–∞—Ç—á.")
        else:
            print("DB Error:", e)
            await callback.answer("‚ùå –°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.")


@router.callback_query(F.data.startswith("unregister_match:"))
async def unregister_from_match(callback: CallbackQuery, db: Database, state: FSMContext):
    match_id = int(callback.data.split(":")[1])
    user_id = callback.from_user.id

    query = """
            DELETE
            FROM registrations
            WHERE match_id = %s
              AND telegram_id = %s \
            """
    await db.execute(query, (match_id, user_id))

    await callback.message.answer("‚ùå–í–∏ –≤—ñ–¥–º–æ–≤–∏–ª–∏—Å—è –≤—ñ–¥ –º–∞—Ç—á—É. "
                                  "–ù–∞–ø–∏—à—ñ—Ç—å –ø—Ä–∏—á–∏–Ω—É, —á–æ–º—É –≤–∏ –Ω–µ –ø—Ä–∏–π–¥–µ—Ç–µ —ñ –∑–∞–ø—Ä–æ–ø–æ–Ω—É–π—Ç–µ (—è–∫—â–æ –º–æ–∂–ª–∏–≤–æ) —Å–≤—ñ–π —á–∞—Å. ")

    await state.set_state(GameStates.waiting_for_decline_reason)
    await state.update_data(match_id=match_id)

@router.message(GameStates.waiting_for_decline_reason)
async def process_decline_reason(message: Message, db: Database, state: FSMContext):
    reason = message.text.strip()
    data = await state.get_data()
    match_id = data.get("match_id")
    telegram_id = message.from_user.id
    username = message.from_user.username
    query_get_user = """
                     SELECT first_name, username FROM users WHERE telegram_id = %s \
                     """
    async with db.pool.acquire() as conn:
        async with conn.cursor() as cur:
            await cur.execute(query_get_user, telegram_id)
            user = await cur.fetchone()
            if not user:
                raise ValueError("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –±–∞–∑—ñ.")
            first_name, username = user
    query = """
            INSERT INTO registrations (match_id, telegram_id, first_name, username, registered_at, message)
            VALUES (%s, %s, %s, %s, NOW(), %s) \
            """
    await db.execute(query, (match_id, telegram_id, first_name, username, reason))
    await message.answer("üëå –î—è–∫—É—é, –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–µ –∞–¥–º—ñ–Ω—É!")
    await state.clear()



@router.callback_query(F.data.startswith("match_participants:"))
async def show_match_participants(callback: CallbackQuery, db: Database):
    match_id = int(callback.data.split(":")[1])

    query = """
            SELECT first_name, username, message
            FROM registrations
            WHERE match_id = %s \
            """
    participants = await db.fetchall(query, (match_id,))

    if not participants:
        await callback.answer("üòî –©–µ –Ω—ñ—Ö—Ç–æ –Ω–µ –∑–∞–ø–∏—Å–∞–≤—Å—è –Ω–∞ —Ü–µ–π –º–∞—Ç—á.", show_alert=True)
        return

    text = f"üë• <b>–£—á–∞—Å–Ω–∏–∫–∏ –º–∞—Ç—á—É #{match_id}</b>\n\n"
    for idx, (first_name, username,message) in enumerate(participants, start=1):
        if message is not None:
            continue
        if first_name:
            first_name = first_name
        else:
            first_name = "-"
        if username:
            username = username
        else:
            username = "-"
        user_display = f"{first_name}, @{username}"
        text += f"{idx}. {user_display}\n"

    await callback.message.answer(text, parse_mode="HTML")
    await callback.answer()


@router.message(F.text == "üî• –ù–∞—Å—Ç—É–ø–Ω–∏–π –º–∞—Ç—á!")
async def show_next_game(message: Message, db: Database):
    query = """
            SELECT first_name, date, time, message
            FROM schedule
            WHERE date >= CURRENT_DATE
            ORDER BY date, time
                LIMIT 1
            """
    result = await db.fetchone(query)

    if not result:
        await message.answer(
            "üì≠ <b>–†–æ–∑–∫–ª–∞–¥ –ø–æ–∫–∏ —â–æ –ø–æ—Ä–æ–∂–Ω—ñ–π</b>\n\n"
            "üîî –í–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, –∫–æ–ª–∏ –∞–¥–º—ñ–Ω –¥–æ–¥–∞—Å—Ç—å –Ω–æ–≤–∏–π –º–∞—Ç—á!\n\n"
            "‚öΩ –ì–æ—Ç—É–π—Ç–µ—Å—è –¥–æ –≥—Ä–∏!"
        )
        return

    first_name, date, time_, msg = result

    from datetime import datetime
    try:
        date_obj = datetime.strptime(str(date), "%Y-%m-%d")
        formatted_date = date_obj.strftime("%d.%m.%Y")
        day_name = ["–ü–æ–Ω–µ–¥—ñ–ª–æ–∫", "–í—ñ–≤—Ç–æ—Ä–æ–∫", "–°–µ—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä", "–ü'—è—Ç–Ω–∏—Ü—è", "–°—É–±–æ—Ç–∞", "–ù–µ–¥—ñ–ª—è"][date_obj.weekday()]
    except:
        formatted_date = str(date)
        day_name = ""

    text = "üéØ <b>–ù–ê–°–¢–£–ü–ù–ò–ô –ú–ê–¢–ß</b>\n"
    text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
    text += f"üìÖ <b>–î–∞—Ç–∞:</b> {formatted_date} ({day_name})\n"
    text += f"üïê <b>–ß–∞—Å:</b> {time_}\n"
    text += f"üë®‚Äçüíº <b>–û—Ä–≥–∞–Ω—ñ–∑–∞—Ç–æ—Ä:</b> {first_name}\n"
    text += f"üìã <b>–î–µ—Ç–∞–ª—ñ:</b> {msg}\n\n"
    text += "‚ö° <i>–ù–µ –ø—Ä–æ–ø—É—Å—Ç–∏ –≥—Ä—É!</i> ‚ö°"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîÑ –û–Ω–æ–≤–∏—Ç–∏", callback_data="refresh_next_game")]
    ])

    await message.answer(text, reply_markup=keyboard)


@router.callback_query(F.data == "refresh_my_matches")
async def refresh_my_matches(callback: CallbackQuery, db: Database):
    query = """
            SELECT s.date, s.time, s.message
            FROM registrations r
                     JOIN schedule s ON s.id = r.match_id
            WHERE r.telegram_id = %s AND (r.message IS NULL OR r.message = '')
            ORDER BY s.date, s.time \
            """
    matches = await db.fetchall(query, (callback.from_user.id,))

    if not matches:
        await callback.message.edit_text(
            "üì≠ <b>–í–∏ —â–µ –Ω–µ –∑–∞–ø–∏—Å–∞–ª–∏—Å—è –Ω–∞ –∂–æ–¥–µ–Ω –º–∞—Ç—á</b>\n\n"
            "üîî –ü–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ —Ä–æ–∑–∫–ª–∞–¥ —Ç–∞ –∑–∞–ø–∏—à—ñ—Ç—å—Å—è –Ω–∞ –º–∞–π–±—É—Ç–Ω—ñ —ñ–≥—Ä–∏!\n\n"
            "‚öΩ –ì–æ—Ç—É–π—Ç–µ—Å—è –¥–æ –≥—Ä–∏!"
        )
        await callback.answer("üîÑ –û–Ω–æ–≤–ª–µ–Ω–æ!")
        return

    from datetime import datetime
    
    text = "üìã <b>–í–ê–®–Ü –ó–ê–ü–õ–ê–ù–û–í–ê–ù–Ü –ú–ê–¢–ß–Ü</b>\n"
    text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
    
    for i, (date, time_, schedule_msg) in enumerate(matches, 1):
        try:
            date_obj = datetime.strptime(str(date), "%Y-%m-%d")
            formatted_date = date_obj.strftime("%d.%m.%Y")
            day_name = ["–ü–æ–Ω–µ–¥—ñ–ª–æ–∫", "–í—ñ–≤—Ç–æ—Ä–æ–∫", "–°–µ—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä", "–ü'—è—Ç–Ω–∏—Ü—è", "–°—É–±–æ—Ç–∞", "–ù–µ–¥—ñ–ª—è"][date_obj.weekday()]
        except:
            formatted_date = str(date)
            day_name = ""
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        if schedule_msg is None:
            schedule_msg = "–ë–µ–∑ –¥–µ—Ç–∞–ª–µ–π"
        
        text += f"üéØ <b>–ú–ê–¢–ß #{i}</b>\n"
        text += f"üìÖ <b>–î–∞—Ç–∞:</b> {formatted_date} ({day_name})\n"
        text += f"üïê <b>–ß–∞—Å:</b> {time_}\n"
        text += f"üìã <b>–î–µ—Ç–∞–ª—ñ –º–∞—Ç—á—É:</b> {schedule_msg}\n\n"
    
    text += "‚ö° <i>–ü–æ–±–∞—á–∏–º–æ—Å—è –Ω–∞ –ø–æ–ª—ñ!</i> ‚ö°"

    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîÑ –û–Ω–æ–≤–∏—Ç–∏", callback_data="refresh_my_matches")]
    ])

    await callback.message.edit_text(text, reply_markup=keyboard)
    await callback.answer("üîÑ –û–Ω–æ–≤–ª–µ–Ω–æ!")


@router.callback_query(F.data == "refresh_schedule")
async def refresh_schedule(callback: CallbackQuery, db: Database):
    query = """
            SELECT first_name, date, time, message
            FROM schedule
            ORDER BY date, time \
            """
    result = await db.fetchall(query)

    if not result:
        await callback.message.edit_text(
            "üì≠ <b>–†–æ–∑–∫–ª–∞–¥ –ø–æ–∫–∏ —â–æ –ø–æ—Ä–æ–∂–Ω—ñ–π</b>\n\n"
            "üîî –í–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, –∫–æ–ª–∏ –∞–¥–º—ñ–Ω –¥–æ–¥–∞—Å—Ç—å –Ω–æ–≤–∏–π –º–∞—Ç—á!\n\n"
            "‚öΩ –ì–æ—Ç—É–π—Ç–µ—Å—è –¥–æ –≥—Ä–∏!"
        )
        await callback.answer("üîÑ –†–æ–∑–∫–ª–∞–¥ –æ–Ω–æ–≤–ª–µ–Ω–æ!")
        return

    # –¢–æ–π —Å–∞–º–∏–π –∫–æ–¥ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è, —è–∫ —ñ –≤–∏—â–µ
    from datetime import datetime
    matches_by_date = {}
    for row in result:
        first_name, date, time_, msg = row
        date_key = str(date)
        if date_key not in matches_by_date:
            matches_by_date[date_key] = []
        matches_by_date[date_key].append((first_name, date, time_, msg))

    text = "‚öΩ <b>üèÜ –†–û–ó–ö–õ–ê–î –ú–ê–¢–ß–Ü–í üèÜ</b> ‚öΩ\n"
    text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"

    match_count = 0
    for date_key, matches in matches_by_date.items():
        try:
            date_obj = datetime.strptime(date_key, "%Y-%m-%d")
            formatted_date = date_obj.strftime("%d.%m.%Y")
            day_name = ["–ü–æ–Ω–µ–¥—ñ–ª–æ–∫", "–í—ñ–≤—Ç–æ—Ä–æ–∫", "–°–µ—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä", "–ü'—è—Ç–Ω–∏—Ü—è", "–°—É–±–æ—Ç–∞", "–ù–µ–¥—ñ–ª—è"][date_obj.weekday()]
        except:
            formatted_date = date_key
            day_name = ""

        text += f"üìÖ <b>{formatted_date}</b>"
        if day_name:
            text += f" ({day_name})"
        text += "\n"
        text += "‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà\n"

        for first_name, date, time_, msg in matches:
            match_count += 1
            text += f"üéØ <b>–ú–∞—Ç—á #{match_count}</b>\n"
            text += f"üïê <b>–ß–∞—Å:</b> {time_}\n"
            text += f"üë®‚Äçüíº <b>–û—Ä–≥–∞–Ω—ñ–∑–∞—Ç–æ—Ä:</b> {first_name}\n"
            text += f"üìã <b>–î–µ—Ç–∞–ª—ñ:</b> {msg}\n"
            text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"

    text += "‚ö° <i>–ó–∞–≤–∂–¥–∏ –±—É–¥—å—Ç–µ –≥–æ—Ç–æ–≤—ñ –¥–æ –≥—Ä–∏!</i> ‚ö°\n"
    text += "üî• <i>–§—É—Ç–±–æ–ª - —Ü–µ –∂–∏—Ç—Ç—è!</i> üî•"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="üîÑ –û–Ω–æ–≤–∏—Ç–∏", callback_data="refresh_schedule"),
            InlineKeyboardButton(text="üì± –ü–æ–¥—ñ–ª–∏—Ç–∏—Å—è", callback_data="share_schedule")
        ]
    ])

    await callback.message.edit_text(text, reply_markup=keyboard)
    await callback.answer("üîÑ –†–æ–∑–∫–ª–∞–¥ –æ–Ω–æ–≤–ª–µ–Ω–æ!")


@router.callback_query(F.data == "share_schedule")
async def share_schedule(callback: CallbackQuery):
    share_text = "ü§ù <b>–ü–æ–¥—ñ–ª—ñ—Ç—å—Å—è —Ä–æ–∑–∫–ª–∞–¥–æ–º –∑ –¥—Ä—É–∑—è–º–∏!</b>\n\n"
    share_text += "‚öΩ –ó–∞–ø—Ä–æ—Å—ñ—Ç—å —ó—Ö –¥–æ –Ω–∞—à–æ—ó —Ñ—É—Ç–±–æ–ª—å–Ω–æ—ó –∫–æ–º–∞–Ω–¥–∏!\n"
    share_text += "üîó –ù–∞–¥—ñ—à–ª—ñ—Ç—å —ó–º –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –±–æ—Ç–∞: @PivoStreet_bot"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥ –¥–æ —Ä–æ–∑–∫–ª–∞–¥—É", callback_data="back_to_schedule")]
    ])

    await callback.message.edit_text(share_text, reply_markup=keyboard)
    await callback.answer()


@router.callback_query(F.data == "back_to_schedule")
async def back_to_schedule(callback: CallbackQuery, db: Database):
    # –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ—Å—è –¥–æ —Ä–æ–∑–∫–ª–∞–¥—É
    query = """
            SELECT first_name, date, time, message
            FROM schedule
            ORDER BY date, time \
            """
    result = await db.fetchall(query)

    if not result:
        await callback.message.edit_text(
            "üì≠ <b>–†–æ–∑–∫–ª–∞–¥ –ø–æ–∫–∏ —â–æ –ø–æ—Ä–æ–∂–Ω—ñ–π</b>\n\n"
            "üîî –í–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è, –∫–æ–ª–∏ –∞–¥–º—ñ–Ω –¥–æ–¥–∞—Å—Ç—å –Ω–æ–≤–∏–π –º–∞—Ç—á!\n\n"
            "‚öΩ –ì–æ—Ç—É–π—Ç–µ—Å—è –¥–æ –≥—Ä–∏!"
        )
        await callback.answer()
        return

    from datetime import datetime
    matches_by_date = {}
    for row in result:
        first_name, date, time_, msg = row
        date_key = str(date)
        if date_key not in matches_by_date:
            matches_by_date[date_key] = []
        matches_by_date[date_key].append((first_name, date, time_, msg))

    text = "‚öΩ <b>üèÜ –†–û–ó–ö–õ–ê–î –ú–ê–¢–ß–Ü–í üèÜ</b> ‚öΩ\n"
    text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"

    match_count = 0
    for date_key, matches in matches_by_date.items():
        try:
            date_obj = datetime.strptime(date_key, "%Y-%m-%d")
            formatted_date = date_obj.strftime("%d.%m.%Y")
            day_name = ["–ü–æ–Ω–µ–¥—ñ–ª–æ–∫", "–í—ñ–≤—Ç–æ—Ä–æ–∫", "–°–µ—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä", "–ü'—è—Ç–Ω–∏—Ü—è", "–°—É–±–æ—Ç–∞", "–ù–µ–¥—ñ–ª—è"][date_obj.weekday()]
        except:
            formatted_date = date_key
            day_name = ""

        text += f"üìÖ <b>{formatted_date}</b>"
        if day_name:
            text += f" ({day_name})"
        text += "\n"
        text += "‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà\n"

        for first_name, date, time_, msg in matches:
            match_count += 1
            text += f"üéØ <b>–ú–∞—Ç—á #{match_count}</b>\n"
            text += f"üïê <b>–ß–∞—Å:</b> {time_}\n"
            text += f"üë®‚Äçüíº <b>–û—Ä–≥–∞–Ω—ñ–∑–∞—Ç–æ—Ä:</b> {first_name}\n"
            text += f"üìã <b>–î–µ—Ç–∞–ª—ñ:</b> {msg}\n"
            text += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"

    text += "‚ö° <i>–ó–∞–≤–∂–¥–∏ –±—É–¥—å—Ç–µ –≥–æ—Ç–æ–≤—ñ –¥–æ –≥—Ä–∏!</i> ‚ö°\n"
    text += "üî• <i>–§—É—Ç–±–æ–ª - —Ü–µ –∂–∏—Ç—Ç—è!</i> üî•"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="üîÑ –û–Ω–æ–≤–∏—Ç–∏", callback_data="refresh_schedule"),
            InlineKeyboardButton(text="üì± –ü–æ–¥—ñ–ª–∏—Ç–∏—Å—è", callback_data="share_schedule")
        ]
    ])

    await callback.message.edit_text(text, reply_markup=keyboard)
    await callback.answer()


@router.message(F.text == "üìã –ú–æ—ó –º–∞—Ç—á—ñ")
async def my_registrations(message: Message, db: Database):
    query = """
            SELECT s.date, s.time, s.message
            FROM registrations r
                     JOIN schedule s ON s.id = r.match_id
            WHERE r.telegram_id = %s AND (r.message IS NULL OR r.message = '')
            ORDER BY s.date, s.time \
            """
    matches = await db.fetchall(query, (message.from_user.id,))

    if not matches:
        await message.answer(
            "üì≠ <b>–í–∏ —â–µ –Ω–µ –∑–∞–ø–∏—Å–∞–ª–∏—Å—è –Ω–∞ –∂–æ–¥–µ–Ω –º–∞—Ç—á</b>\n\n"
            "üîî –ü–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ —Ä–æ–∑–∫–ª–∞–¥ —Ç–∞ –∑–∞–ø–∏—à—ñ—Ç—å—Å—è –Ω–∞ –º–∞–π–±—É—Ç–Ω—ñ —ñ–≥—Ä–∏!\n\n"
            "‚öΩ –ì–æ—Ç—É–π—Ç–µ—Å—è –¥–æ –≥—Ä–∏!"
        )
        return

    from datetime import datetime
    
    text = "üìã <b>–í–ê–®–Ü –ó–ê–ü–õ–ê–ù–û–í–ê–ù–Ü –ú–ê–¢–ß–Ü</b>\n"
    text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
    
    for i, (date, time_, schedule_msg) in enumerate(matches, 1):
        try:
            date_obj = datetime.strptime(str(date), "%Y-%m-%d")
            formatted_date = date_obj.strftime("%d.%m.%Y")
            day_name = ["–ü–æ–Ω–µ–¥—ñ–ª–æ–∫", "–í—ñ–≤—Ç–æ—Ä–æ–∫", "–°–µ—Ä–µ–¥–∞", "–ß–µ—Ç–≤–µ—Ä", "–ü'—è—Ç–Ω–∏—Ü—è", "–°—É–±–æ—Ç–∞", "–ù–µ–¥—ñ–ª—è"][date_obj.weekday()]
        except:
            formatted_date = str(date)
            day_name = ""
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        if schedule_msg is None:
            schedule_msg = "–ë–µ–∑ –¥–µ—Ç–∞–ª–µ–π"
        
        text += f"üéØ <b>–ú–ê–¢–ß #{i}</b>\n"
        text += f"üìÖ <b>–î–∞—Ç–∞:</b> {formatted_date} ({day_name})\n"
        text += f"üïê <b>–ß–∞—Å:</b> {time_}\n"
        text += f"üìã <b>–î–µ—Ç–∞–ª—ñ –º–∞—Ç—á—É:</b> {schedule_msg}\n\n"
    
    text += "‚ö° <i>–ü–æ–±–∞—á–∏–º–æ—Å—è –Ω–∞ –ø–æ–ª—ñ!</i> ‚ö°"

    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîÑ –û–Ω–æ–≤–∏—Ç–∏", callback_data="refresh_my_matches")]
    ])

    await message.answer(text, reply_markup=keyboard)
